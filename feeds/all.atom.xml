<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Generic Surname</title><link href="http://jrsmith3.github.io/" rel="alternate"></link><link href="http://jrsmith3.github.io/feeds/all.atom.xml" rel="self"></link><id>http://jrsmith3.github.io/</id><updated>2014-06-26T00:00:00-04:00</updated><entry><title>Scratchwork branches</title><link href="http://jrsmith3.github.io/scratchwork-branches.html" rel="alternate"></link><updated>2014-06-26T00:00:00-04:00</updated><author><name>Joshua Ryan Smith</name></author><id>tag:jrsmith3.github.io,2014-06-26:scratchwork-branches.html</id><summary type="html">&lt;p&gt;I have a question that I'd like to pose to more advanced software developers if any are out there.&lt;/p&gt;
&lt;p&gt;Yesterday I wrote some code and tests to implement some medium-complex functionality (branch &lt;code&gt;surf_enh&lt;/code&gt; in the picture). The result was ok, but I ended up with a situation where I had painted myself into a corner. So today I started over pretty much from scratch; I reverted back to the point in the repo where I had started yesterday, and applied the lessons I had learned (branch &lt;code&gt;slab&lt;/code&gt;) while avoiding the cul-de-sac I ended up in yesterday. A lot of the code in &lt;code&gt;slab&lt;/code&gt; is copied from &lt;code&gt;surf_enh&lt;/code&gt; with some minor modifications.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Two days' work." src="images/two_days.png" /&gt;&lt;/p&gt;
&lt;p&gt;My question is: what do I do with branch &lt;code&gt;surf_enh&lt;/code&gt;? I'm thinking about this branch in terms of an early draft of a manuscript; some days you write copy with the understanding that you will pretty much completely rewrite it from scratch on a subsequent revision. When I write manuscripts or papers, I like to keep earlier revisions for posterity. Similarly, I would like to keep the commits and commit messages in &lt;code&gt;surf_enh&lt;/code&gt;. However, it seems like keeping a whole named branch in the repo would be crufty.&lt;/p&gt;
&lt;p&gt;Do you ever see this pattern where you have a scratchwork branch in your repo that you subsequently completely refactor? If so, do you keep these scratchwork branches? How do you prevent them from crufting up the list of branch names? Should I use a tag?&lt;/p&gt;</summary></entry><entry><title>Data storage and data file workflow</title><link href="http://jrsmith3.github.io/data-storage-and-data-file-workflow.html" rel="alternate"></link><updated>2014-06-22T00:00:00-04:00</updated><author><name>Joshua Ryan Smith</name></author><id>tag:jrsmith3.github.io,2014-06-22:data-storage-and-data-file-workflow.html</id><summary type="html">&lt;h1&gt;Summary&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Raw data files should be stored in a single directory named &lt;code&gt;data&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data&lt;/code&gt; should be centrally accessible.&lt;/li&gt;
&lt;li&gt;Files in &lt;code&gt;data&lt;/code&gt; should have &lt;a href="http://jrsmith3.github.io/naming-data-files.html"&gt;unique names&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data&lt;/code&gt; should have a flat structure (no subdirectories).&lt;/li&gt;
&lt;li&gt;Files in &lt;code&gt;data&lt;/code&gt; should remain pristine as they came off the instrument and never be altered.&lt;/li&gt;
&lt;li&gt;Do not use &lt;code&gt;data&lt;/code&gt; as a working directory. I.e. don't put code, manuscripts, etc. in &lt;code&gt;data&lt;/code&gt;; use a project directory instead.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;If you are like me, in the course of your research you generate data files from the various apparatus used in your experiments. These may be SEM images in TIFF format, files containing I-V data for your Schottky diodes in ASCII format, or AFM images in some proprietary binary format. How should you organize these files? How should you store them so others can get access when they need to (without bothering you)? How can you keep track of them and any changes during data analysis?&lt;/p&gt;
&lt;h1&gt;The solution: unique filenames, read-only files, and a single, flat &lt;code&gt;data&lt;/code&gt; directory&lt;/h1&gt;
&lt;p&gt;Most of your data management issues can be resolved by adopting a single, flat (no subdirectories), centrally accessable directory containing read-only copies of your group's data files which are uniquely named.&lt;/p&gt;
&lt;p&gt;The workflow for this kind of system is straightforward: data is taken on an instrument and gets copied to &lt;code&gt;data&lt;/code&gt;. If analysis is to be done on files in &lt;code&gt;data&lt;/code&gt;, the person analyzing the data would first copy the files into a different project directory and then perform the analysis.&lt;/p&gt;
&lt;p&gt;Having all data in a single, centrally accessible &lt;code&gt;data&lt;/code&gt; directory has a number of advantages. First, this approach eliminates findability costs. People will never have to go around to different computers looking for the data they took. Second, this approach decreases transaction costs. If you need data that I took, simply find it in &lt;code&gt;data&lt;/code&gt;. There's no need to ask me to email or otherwise send you the data.&lt;/p&gt;
&lt;p&gt;This approach to data management is strongly coupled to choosing &lt;a href="http://jrsmith3.github.io/naming-data-files.html"&gt;unique, metadata-rich filenames&lt;/a&gt;. To recap, use &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;YYYYMMDD&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;HHMM_experiment_sample_experimenter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extension&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;on systems that support long filenames and the nested directory structure&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;experimenter&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;YYYYMMDD&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;experiment&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;sample&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;HHMM&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extension&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;on older systems that do not support long filenames.&lt;/p&gt;
&lt;p&gt;Having a &lt;code&gt;data&lt;/code&gt; directory filled with uniquely and descriptively named files is the next best thing to having a &lt;a href="https://en.wikipedia.org/wiki/Uniform_resource_identifier"&gt;URI&lt;/a&gt; for each file and having the files in some kind of relational database. In addition to the advantage of findability I mentioned above, uniquely naming files in a single &lt;code&gt;data&lt;/code&gt; directory yields addressability. Cross-referencing a file in a &lt;a href="http://jrsmith3.github.io/effective-lab-notebooks.html"&gt;lab notebook&lt;/a&gt; or &lt;a href="http://jrsmith3.github.io/sample-logs-the-secret-to-managing-multi-person-projects.html"&gt;sample log&lt;/a&gt; is as simple as writing the filename. To find the cross-referenced file, simply look for it in &lt;code&gt;data&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;Using metadata-rich filenames gives you another advantage: it is easy to perform searches for specific files or sets of files using filename search functions in your file browser or shell. More advanced searches can be done via simple python scripts. For example, lets say I wanted to find all the XPS data files I've taken&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gamma:data jrsmith3&lt;span class="nv"&gt;$ &lt;/span&gt;ls | grep -i jrs | grep -i xps
20100202-0844_xps_tfan25_jrs.dat
20100202-0850_xps_tfan25_jrs.dat
20100202-1008_xps_tfan25_jrs.dat
20100202-1019_xps_tfan25_jrs.dat
20100202-1127_xps_tfan25_jrs.dat
20100202-1133_xps_tfan25_jrs.dat
20100202-1223_xps_tfan25_jrs.dat
20100202-1227_xps_tfan25_jrs.dat
20100202-1324_xps_tfan25_jrs.dat
20100202-1330_xps_tfan25_jrs.dat
20100203-0823_xps_tfan24_jrs.dat
20100203-0829_xps_tfan24_jrs.dat
20100203-0932_xps_tfan24_jrs.dat
20100203-0937_xps_tfan24_jrs.dat
20100203-0956_xps_tfan24_jrs.dat
20100203-1033_xps_tfan24_jrs.dat
20100203-1039_xps_tfan24_jrs.dat
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The same search can be performed from OSX Finder. I don't use Windows, but I would be happy to post instructions on the same search from powershell or Windows file Explorer, &lt;a href="mailto:joshua.r.smith@gmail.com"&gt;email&lt;/a&gt; me or pull request.&lt;/p&gt;
&lt;p&gt;Using the file naming scheme I suggest above gives one final advantage. File browsers and the shell will automatically list files in chronological order. In the bash shell:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gamma:data jrsmith3&lt;span class="nv"&gt;$ &lt;/span&gt;ls
20110520-1543_stm_jrs0075_jrs.sm4
20110520-1614_stm_jrs0075_jrs.sm4
20110520-1622_oscilloscope_jrs0075_jrs.txt
20110520-1623_stm_jrs0075_jrs.sm4
20110520-1700_stm_jrs0075_jrs.sm4
20110520-1709_stm_jrs0075_jrs.sm4
20110520-1721_stm_jrs0075_jrs.sm4
20110520-1731_stm_jrs0075_jrs.sm4
20110520-1742_stm_jrs0075_jrs.sm4
20110520-1819_stm_jrs0076_jrs.sm4
20110520-1830_stm_jrs0076_jrs.sm4
20110520-1840_stm_jrs0076_jrs.sm4
20110520-1840_stm_jrs0076_jrs.txt
20110520-1916_stm_jrs0076_jrs.sm4
20110520-1925_stm_jrs0076_jrs.sm4
20110520-2002_stm_jrs0076_jrs.sm4
20110523-1052_xps_jrs0076_jrs.dat
20110523-1110_xps_jrs0076_jrs.dat
20110527-1614_TEM_JRST27_ATW.dm3
20110527-1615_TEM_JRST27_ATW.dm3
20110527-1617_TEM_JRST27_ATW.dm3
20110527-1619_TEM_JRST27_ATW.dm3
20110527-162412_TEM_JRST26_ATW.dm3
20110527-162430_TEM_JRST26_ATW.dm3
20110527-1627_TEM_JRST26_ATW.dm3
20110527-1628_TEM_JRST26_ATW.dm3
20110527-1635_TEM_JRST26_ATW.dm3
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Workflow&lt;/h1&gt;
&lt;p&gt;The workflow is pretty simple: Data files are created on the instrument and are named appropriately. Data then moves into the &lt;code&gt;data&lt;/code&gt; directory either directly or via an intermediate medium such as a USB flash drive. If you are on Windows, I believe &lt;a href="http://winscp.net/eng/index.php"&gt;WinSCP&lt;/a&gt; has a nice &lt;a href="http://winscp.net/eng/docs/guide_synchronize"&gt;synchronization&lt;/a&gt; capability.&lt;/p&gt;
&lt;h1&gt;Cautions&lt;/h1&gt;
&lt;p&gt;There are two related issues that you should avoid. First, putting all data in a single directory creates a single point of failure. I suggest having a robust backup and recovery plan for this directory.&lt;/p&gt;
&lt;p&gt;The second thing you should avoid is altering any data that is located in the &lt;code&gt;data&lt;/code&gt; directory. Oftentimes you will need to do some kind of analysis that changes the data file itself; if so, make a copy of the data you need and modify the copy. To reiterate: once data lands in the &lt;code&gt;data&lt;/code&gt; directory, it should never change.&lt;/p&gt;
&lt;p&gt;Putting &lt;code&gt;data&lt;/code&gt; under version control might not be a bad idea. Some people might balk at having a big repo, but apparently some companies do it.&lt;/p&gt;
&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;p&gt;Facebook&amp;#39;s git repo is 54 GB. &lt;a href="http://t.co/zLNSzDlFYF"&gt;pic.twitter.com/zLNSzDlFYF&lt;/a&gt;&lt;/p&gt;&amp;mdash; Feross (@feross) &lt;a href="https://twitter.com/feross/statuses/459259593630433280"&gt;April 24, 2014&lt;/a&gt;&lt;/blockquote&gt;

&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;

&lt;p&gt;I would recommend using git or another vcs if your lab's data is a few hundred MBs.&lt;/p&gt;
&lt;h1&gt;Short filenames&lt;/h1&gt;
&lt;p&gt;If you've been paying attention, you will have noticed a contradiction. According to my file naming rubric, short filenames are necessarily in a nested directory structure but I advocate a flat structure for &lt;code&gt;data&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The best case scenario would be to have some scripts for various platforms which would flatten the nested structure in &lt;code&gt;data&lt;/code&gt;. I will post links to these scripts when they become available. In the meantime, the nested structure I suggest makes drag-and-drop additions to the &lt;code&gt;data&lt;/code&gt; directory easy. To keep things in &lt;code&gt;data&lt;/code&gt; clean, use a single subdirectory named &lt;code&gt;nested&lt;/code&gt; to store all of the data in nested directories coming from computers constrained to short filenames. According to my nested directory naming scheme, the &lt;code&gt;nested&lt;/code&gt; directory will contain subdirectories corresponding to each experimenter. Each experimenter's directory will end up having a series of &lt;code&gt;YYYYMMDD&lt;/code&gt; subdirectories. In this way, everyone can simply drag-and-drop newly acquired data into a new &lt;code&gt;YYYYMMDD&lt;/code&gt; subdirectory in their own directory.&lt;/p&gt;
&lt;p&gt;Here's a visualization:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;tree data/
data/
└── nested
    ├── jrs
    │   └── 20140622
    │       └── xps
    │           └── jrs0014
    │               ├── 0943.dat
    │               ├── 0950.dat
    │               ├── 1002.dat
    │               ├── 1307.dat
    │               └── 1320.dat
    └── rpt

6 directories, 5 files
&lt;/pre&gt;&lt;/div&gt;</summary></entry><entry><title>Migrating a LaTeX manuscript hosted on GitHub to Authorea</title><link href="http://jrsmith3.github.io/migrating-a-latex-manuscript-hosted-on-github-to-authorea.html" rel="alternate"></link><updated>2014-05-15T23:28:00-04:00</updated><author><name>Joshua Ryan Smith</name></author><id>tag:jrsmith3.github.io,2014-05-15:migrating-a-latex-manuscript-hosted-on-github-to-authorea.html</id><summary type="html">&lt;h1&gt;Summary&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Start with a LaTeX document hosted in an existing GitHub repo.&lt;/li&gt;
&lt;li&gt;Create a new article on Authorea by importing the main LaTeX document source.&lt;/li&gt;
&lt;li&gt;Connect the Authorea document to the exisiting GitHub repo by&lt;ul&gt;
&lt;li&gt;generating Authorea document ssh keys&lt;/li&gt;
&lt;li&gt;setting up a GitHub webhook.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Fix and reorganize the resulting files that Authorea creates.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Authorea + GitHub: extreme power plus low barrier to entry?&lt;/h1&gt;
&lt;p&gt;Without having used it extensively, I am very excited about &lt;a href="https://authorea.com/"&gt;Authorea&lt;/a&gt;. Authorea looks like the collaborative authoring tool I would have created. It allows teams to collaborate on LaTeX documents, and it has a git backend that can be connected to a GitHub repository. My hope is that Authorea will bridge a gap: it will allow people with a lot of git and LaTeX experience to collaborate on manuscripts with people that have none. In this way, hopefully the group can operate at the level of the most computer savvy members as opposed to regressing to the lowest-common-denominator .doc + email workflow. Longer term, perhaps the people with less experience will get a gentle introduction to version control and markup languages so they can see the value without having to pass through &lt;a href="http://software-carpentry.org/blog/2014/05/playing-the-kazoo.html#glass-law"&gt;the valley of death&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Authorea is currently thin on the documentation of how to connect to an existing LaTeX document hosted on GitHub. This post will be a case study of how I integrated Authorea into an existing LaTeX document on GitHub. I will use an example &lt;a href="https://github.com/jrsmith3/authorea_test"&gt;GitHub repo called authorea_test&lt;/a&gt; and &lt;a href="https://authorea.com/users/6814/articles/7173/"&gt;Authorea document&lt;/a&gt; so that you can poke around the result.&lt;/p&gt;
&lt;h1&gt;Step 0: Prep initial LaTeX manuscript on GitHub&lt;/h1&gt;
&lt;p&gt;I started with a simple LaTeX document hosted in a GitHub repo. Release &lt;a href="https://github.com/jrsmith3/authorea_test/releases/tag/1.0"&gt;1.0&lt;/a&gt; is the state of the repository before I connected it to Authorea. My typical workflow is to author or edit the LaTeX source, then build the result with a &lt;a href="https://github.com/jrsmith3/latex_template"&gt;makefile&lt;/a&gt;. I would like to keep this makefile workflow, but I also want the files to be in a form that can be built by Authorea.&lt;/p&gt;
&lt;h2&gt;Make a branch to be merged later&lt;/h2&gt;
&lt;p&gt;Spoiler alert: when you set up access to your GitHub repo by Authorea, Authorea is going to push to &lt;code&gt;master&lt;/code&gt; and merge whatever it finds. I suggest moving whatever is currently in &lt;code&gt;master&lt;/code&gt; to a new branch called &lt;code&gt;latex&lt;/code&gt;, deleting &lt;code&gt;master&lt;/code&gt;, and then merging the two on your own terms.&lt;/p&gt;
&lt;h1&gt;Step 1: Make a new article on Authorea via import&lt;/h1&gt;
&lt;p&gt;Click on the red "New article" button and choose "Import". For "Project name" I chose "authorea_test" to match the repo name on GitHub. For the LaTeX file in the "Source files" section, I navigated to the directory in my local filesystem containing the git repo and chose the &lt;code&gt;main.tex&lt;/code&gt; file. I ended up choosing "Public" in the "Article availability" section for this example, but for my actual proposal I used "Private." Finally, click "Submit."&lt;/p&gt;
&lt;p&gt;&lt;a href="images/01_import_article.png"&gt;&lt;img alt="Import article" src="images/01_import_article_small.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Authorea slices up &lt;code&gt;main.tex&lt;/code&gt; and creates several .tex files. It also alerts me to a rendering error. This error is because Authorea incorrectly parsed my &lt;code&gt;\usepackage{hyperref}&lt;/code&gt; directive. &lt;/p&gt;
&lt;p&gt;&lt;a href="images/02_successful_import_with_error.png"&gt;&lt;img alt="Successful import with error" src="images/02_successful_import_with_error_small.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I'll fix the &lt;code&gt;hyperref&lt;/code&gt; problem momentarily, but first take a look the files that Authorea has created by clicking on the &lt;code&gt;folder&lt;/code&gt; tab.&lt;/p&gt;
&lt;p&gt;&lt;a href="images/03_folder_tab_after_import.png"&gt;&lt;img alt="Folder tab after import" src="images/03_folder_tab_after_import_small.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Authorea has parsed &lt;code&gt;main.tex&lt;/code&gt; and broken out the sections into individual files listed below. Commit &lt;a href="https://github.com/jrsmith3/authorea_test/commit/b737b5f73d60ff46835fc3365ba131b496e34840"&gt;b737b5f7&lt;/a&gt; corresponds to the state of the repo at this point.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;bibliography&lt;/code&gt;&lt;/strong&gt; - A directory containing an empty file called &lt;code&gt;biblio.bib&lt;/code&gt;. Probably my own bibTeX file would have gone here had I uploaded it during the creation of this document.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;figures&lt;/code&gt;&lt;/strong&gt; - An empty directory that would contain figures associated with this manuscript.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;abstract.tex&lt;/code&gt;&lt;/strong&gt; - A file containing the string between the &lt;code&gt;\begin{abstract}&lt;/code&gt; and &lt;code&gt;\end{abstract}&lt;/code&gt; directives in the original &lt;code&gt;main.tex&lt;/code&gt; file.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;header.tex&lt;/code&gt;&lt;/strong&gt; - Contains the LaTeX commands that weren't ignored as part of the preamble or parsed into &lt;code&gt;pdftitleTitle_pdfaut.tex&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;layout.md&lt;/code&gt;&lt;/strong&gt; - Markdown file with a list of LaTeX files. This file appears to list the order in which Authorea assembles the various .tex files to be built.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;pdftitleTitle_pdfaut.tex&lt;/code&gt;&lt;/strong&gt; - The &lt;code&gt;hyperref&lt;/code&gt; package arguments. These commands are what is causing the rendering error.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;preamble.tex&lt;/code&gt;&lt;/strong&gt; - Looks like boilerplate LaTeX preamble.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;sectionIntroduction_.tex&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;\section{}&lt;/code&gt; command and text from the &lt;code&gt;Introduction&lt;/code&gt; section.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;title.tex&lt;/code&gt;&lt;/strong&gt; - Text of title of document. Since I defined my own TeX command to hold the string containing the title, this file simply calls that command.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;untitled.tex&lt;/code&gt;&lt;/strong&gt; - Empty .tex file.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Based on the above files, it looks like Authorea is building a document like the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;\input&lt;/span&gt;&lt;span class="nb"&gt;{&lt;/span&gt;preamble&lt;span class="nb"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;\input&lt;/span&gt;&lt;span class="nb"&gt;{&lt;/span&gt;header&lt;span class="nb"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;\title&lt;/span&gt;&lt;span class="nb"&gt;{&lt;/span&gt;&lt;span class="k"&gt;\input&lt;/span&gt;&lt;span class="nb"&gt;{&lt;/span&gt;title&lt;span class="nb"&gt;}}&lt;/span&gt;
&lt;span class="k"&gt;\author&lt;/span&gt;&lt;span class="nb"&gt;{&lt;/span&gt;&lt;span class="k"&gt;\AuthorName&lt;/span&gt;&lt;span class="nb"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;\begin&lt;/span&gt;&lt;span class="nb"&gt;{&lt;/span&gt;document&lt;span class="nb"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;\maketitle&lt;/span&gt;

&lt;span class="k"&gt;\begin&lt;/span&gt;&lt;span class="nb"&gt;{&lt;/span&gt;abstract&lt;span class="nb"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;\input&lt;/span&gt;&lt;span class="nb"&gt;{&lt;/span&gt;abstract&lt;span class="nb"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;\end&lt;/span&gt;&lt;span class="nb"&gt;{&lt;/span&gt;abstract&lt;span class="nb"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;\input&lt;/span&gt;&lt;span class="nb"&gt;{&lt;/span&gt;sectionIntroduction&lt;span class="nb"&gt;_}&lt;/span&gt;

&lt;span class="k"&gt;\end&lt;/span&gt;&lt;span class="nb"&gt;{&lt;/span&gt;document&lt;span class="nb"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Step 2: Connect Authorea document to GitHub&lt;/h1&gt;
&lt;p&gt;Things in the Authorea document are a bit of a mess. We will first connect to the GitHub repo, clean things up on our local machine, then push back up to GitHub.&lt;/p&gt;
&lt;h2&gt;Authorea ssh keys&lt;/h2&gt;
&lt;p&gt;One of the ways GitHub authenticates access to repositories is via ssh keys. Authorea can generate key pairs for each document; once generated you simply copy your document's public key to the correspondig GitHub repo.&lt;/p&gt;
&lt;p&gt;From the &lt;code&gt;main&lt;/code&gt; tab on Authorea, click on the &lt;code&gt;Settings&lt;/code&gt; button; once the "Article Settings" window pops up, click on the green "setup a deploy key" button. &lt;/p&gt;
&lt;p&gt;&lt;a href="images/04_article_settings_with_deploy_key_button.png"&gt;&lt;img alt="Article Settings with deploy key button" src="images/04_article_settings_with_deploy_key_button_small.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;To create this keypair, click on the "Generate ssh key pair" button. A new window will pop up entitled, "Public Deploy Key." Copy the entire block of text. &lt;/p&gt;
&lt;p&gt;&lt;a href="images/05_authorea_public_deploy_key.png"&gt;&lt;img alt="Authorea public deploy key" src="images/05_authorea_public_deploy_key_small.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Next, navigate over to the GitHub page with the repo containing your LaTeX manuscript. Click on the "Settings" tab. Then click on the "Deploy keys" tab on the next page that pops up. &lt;/p&gt;
&lt;p&gt;&lt;a href="images/06_github_without_public_deploy_key.png"&gt;&lt;img alt="GitHub without public deploy key" src="images/06_github_without_public_deploy_key_small.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Click on "Add deploy key" and then paste the public ssh key that Authorea generated into the "Key" box. I named the key "authorea_auto_generated" but you can pick whatever name you want. Finally, click the green "Add key" button. GitHub may ask you to enter your password to add the public ssh key to the repository.&lt;/p&gt;
&lt;p&gt;&lt;a href="images/07_github_adding_public_deploy_key.png"&gt;&lt;img alt="GitHub adding public deploy key" src="images/07_github_adding_public_deploy_key_small.png" /&gt;&lt;/a&gt;
&lt;a href="images/08_github_with_public_deploy_key.png"&gt;&lt;img alt="GitHub with public deploy key" src="images/08_github_with_public_deploy_key_small.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Here's a recap of what happened: Authorea generated a public/private ssh key pair for the &lt;code&gt;authorea_test&lt;/code&gt; document. We copied the public key into the &lt;code&gt;authorea_test&lt;/code&gt; GitHub repository. Now Authorea has push/pull access to the &lt;code&gt;authorea_test&lt;/code&gt; repo on GitHub.&lt;/p&gt;
&lt;p&gt;We aren't finished. Authorea needs to know the git URL for the GitHub repository, and the GitHub repository needs a webhook.&lt;/p&gt;
&lt;h2&gt;Git URL&lt;/h2&gt;
&lt;p&gt;Before leaving GitHub, navigate back to the repository's main page and copy the "SSH clone URL." Now navigate to the Authorea page and close the ssh public key window. Copy the ssh clone URL into the box in step 2. Authorea now has everything it needs to modify the GitHub repo. Click "Submit."&lt;/p&gt;
&lt;p&gt;&lt;a href="images/09_authorea_github_repo_url.png"&gt;&lt;img alt="Authorea GitHub repo url" src="images/09_authorea_github_repo_url_small.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;GitHub Webhook&lt;/h2&gt;
&lt;p&gt;If everything is successful, Authorea will give you a page with a Web Hook URL. &lt;/p&gt;
&lt;p&gt;&lt;a href="images/10_authorea_git_access_bridge_with_webhook.png"&gt;&lt;img alt="Authorea Git access bridge with webhook" src="images/10_authorea_git_access_bridge_with_webhook_small.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Copy the URL and navigate back to the GitHub page with the repo. Click on the "Settings" tab, but this time click on "Webhooks and Services." &lt;/p&gt;
&lt;p&gt;&lt;a href="images/11_github_webhooks_and_services.png"&gt;&lt;img alt="GitHub webhooks and services" src="images/11_github_webhooks_and_services_small.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Click "Add webook." Paste the URL from Authorea into the "Payload URL" box, then click the green "Add webhook" button.&lt;/p&gt;
&lt;p&gt;&lt;a href="images/12_github_webhooks_add_webhook.png"&gt;&lt;img alt="GitHub webhooks add webhook" src="images/12_github_webhooks_add_webhook_small.png" /&gt;&lt;/a&gt;
&lt;a href="images/13_github_webhooks_and_services_after_webhook_add.png"&gt;&lt;img alt="GitHub webhooks and services after webhook add" src="images/13_github_webhooks_and_services_after_webhook_add_small.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Once the webhook has been set up, Authorea pushes what it has to the GitHub repo and clobbers your stuff via a merge. You should go back to the local directory on your machine and pull in the changes.&lt;/p&gt;
&lt;p&gt;&lt;a href="images/14_github_after_merge.png"&gt;&lt;img alt="GitHub after merge" src="images/14_github_after_merge_small.png" /&gt;&lt;/a&gt;
&lt;a href="images/15_github_network_graph_after_merge.png"&gt;&lt;img alt="GitHub network graph after merge" src="images/15_github_network_graph_after_merge_small.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;At this point, the connection between Authorea and GitHub has been made. I'm pretty sure that every time a push is made to &lt;code&gt;master&lt;/code&gt; on the GitHub repo, Authorea will pull in the changes. Likewise, any time edits are saved on Authorea, Authorea will push the changes to GitHub. I think that if a merge conflict arises, Authorea will push the changes to the branch &lt;code&gt;authorea&lt;/code&gt; and require a manual merge.&lt;/p&gt;
&lt;p&gt;For what its worth, &lt;a href="https://github.com/jrsmith3/authorea_test/releases/tag/2.0"&gt;tag &lt;code&gt;2.0&lt;/code&gt;&lt;/a&gt; points to the commit where Authorea initially merged.&lt;/p&gt;
&lt;h1&gt;Step 3: Reorganizing what Authorea has done&lt;/h1&gt;
&lt;p&gt;Things aren't terrible since all of the original LaTeX in the repo was on its own branch and since &lt;code&gt;master&lt;/code&gt; was only a single commit containing &lt;code&gt;.gitignore&lt;/code&gt;. There's some cruft in &lt;code&gt;master&lt;/code&gt;. Here's a list of the files and how they should be fixed.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;untitled.tex&lt;/code&gt;&lt;/strong&gt; is superfluous and can be deleted. &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;pdftitleTitle_pdfaut.tex&lt;/code&gt;&lt;/strong&gt; contains the mangled &lt;code&gt;hyperref&lt;/code&gt; directive -- &lt;code&gt;pdftitleTitle_pdfaut.tex&lt;/code&gt; can be deleted because...&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;header.tex&lt;/code&gt;&lt;/strong&gt; should be modified to include the non-mangled &lt;code&gt;hyperref&lt;/code&gt; directive.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;sectionIntroduction_.tex&lt;/code&gt;&lt;/strong&gt; should be renamed. I prefer simply &lt;code&gt;introduction.tex&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;preamble.tex&lt;/code&gt;&lt;/strong&gt; should be rewritten with the original preamble.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;layout.md&lt;/code&gt;&lt;/strong&gt; should be edited to remove the line calling for &lt;code&gt;pdftitleTitle_pdfaut.tex&lt;/code&gt;. The line referring to the old &lt;code&gt;sectionIntroduction_.tex&lt;/code&gt; should be updated.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Release &lt;a href="https://github.com/jrsmith3/authorea_test/releases/tag/3.0"&gt;3.0&lt;/a&gt; is the state of the repo after the modifications.&lt;/p&gt;
&lt;h1&gt;Step 4: Merging &lt;code&gt;latex&lt;/code&gt; back into &lt;code&gt;main&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;I still want to be able to clone the repo and build the LaTeX document using the makefile. In order to accomplish this goal, I merged the &lt;code&gt;latex&lt;/code&gt; branch back into &lt;code&gt;master&lt;/code&gt;, and then modified &lt;code&gt;main.tex&lt;/code&gt; to essentially the file at the top of this post. Note that I manually &lt;code&gt;\input{}&lt;/code&gt; the sections in &lt;code&gt;main.tex&lt;/code&gt;; there's probably a way to parse &lt;code&gt;layout.md&lt;/code&gt; but its late and I am tired.&lt;/p&gt;
&lt;p&gt;The result of the merge and subsequent &lt;code&gt;make&lt;/code&gt; can be found in release &lt;a href="https://github.com/jrsmith3/authorea_test/releases/tag/4.0"&gt;4.0&lt;/a&gt;.&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;The process of setting up Authorea as a frontend for a LaTeX document in an existing GitHub is a little wonky. Hopefully the extreme detail of this post helped.&lt;/p&gt;</summary></entry><entry><title>Pre-brief: Collaborative proposal prep via GitHub with non-developer professors</title><link href="http://jrsmith3.github.io/pre-brief-collaborative-proposal-prep-via-github-with-non-developer-professors.html" rel="alternate"></link><updated>2014-04-09T12:47:00-04:00</updated><author><name>Joshua Ryan Smith</name></author><id>tag:jrsmith3.github.io,2014-04-09:pre-brief-collaborative-proposal-prep-via-github-with-non-developer-professors.html</id><summary type="html">&lt;p&gt;I am just starting writing a proposal with a few professors, all of whom are over 40, use Windows and MS Word, and none of whom have any software development experience. To make things more interesting, the team is scattered across the US. My goal is to manage the proposal writing using GitHub, and ultimately use GitHub to collaborate on the papers, software, and other products coming out of this work.&lt;/p&gt;
&lt;p&gt;This post is a pre-brief of the process; I want to record what I've done to introduce my collaborators to a git-based workflow via GitHub, and some thoughts and concerns before sending out the email asking them to set up a GitHub account.&lt;/p&gt;
&lt;p&gt;I intend to post updates during the proposal writing process, and I will post a debrief once the proposal has been submitted. In these posts, I will cover what worked and what didn't work.&lt;/p&gt;
&lt;h1&gt;Motivation&lt;/h1&gt;
&lt;p&gt;My experience is that the default method of collaboration is completely ad-hoc and consists of emailing various versions of documents. There typically is not a central location, such as a fileserver, on which documents and data are stored.&lt;/p&gt;
&lt;p&gt;I've seen GitHub used &lt;a href="https://github.com/swcarpentry/"&gt;successfully&lt;/a&gt; to coordinate the &lt;a href="http://software-carpentry.org"&gt;Software-Carpentry&lt;/a&gt; project. I believe that several contributors to SWC use a git or GitHub based workflow to coordinate the work in their labs.&lt;/p&gt;
&lt;p&gt;I believe the git workflow can be applied to most parts of the proposed project and the goal is to impose this workflow in at the very beginning of the project.&lt;/p&gt;
&lt;h1&gt;Preparation&lt;/h1&gt;
&lt;p&gt;I've had several phone and email conversations with my collaborators, to sketch out the scope of the proposal and to get their feedback and buy-in. I have sent them drafts of a document, in PDF, that will ultimately become the proposal. This proto-proposal was prepared using LaTeX, but the whitepaper and proposal itself will be prepared using markdown.&lt;/p&gt;
&lt;p&gt;I am currently at the point where I need to invite my collaborators to edit the proposal. I have set everything up to (hopefully) reduce friction as much as possible; to this end I have prepared a few items:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;An opening email.&lt;/li&gt;
&lt;li&gt;A private GitHub repository containing the files for the proposal.&lt;/li&gt;
&lt;li&gt;A README in the root directory of the repo.&lt;/li&gt;
&lt;li&gt;Additional instructions on git, GitHub, and markdown.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Email&lt;/h2&gt;
&lt;p&gt;This invitational email is about 500 words long and includes several components: I mention the scope of the project, I mention the fact that the first step in the process is to submit a whitepaper, and the date I hope to submit the whitepaper. I also give some simple instructions for how to create an account on github in order to access the repository. Finally, I briefly sketch out how the markdown/GitHub workflow is different from the MS Word/email workflow.&lt;/p&gt;
&lt;h2&gt;Repo&lt;/h2&gt;
&lt;p&gt;Before sending out the invitation email, I created an organization for this project, and set up a private repository on GitHub.&lt;/p&gt;
&lt;h2&gt;README&lt;/h2&gt;
&lt;p&gt;In the root of the GitHub repo, I created a 200 word &lt;code&gt;README.md&lt;/code&gt; that will be displayed when people visit the repo page. This file has a section of links to the relevant documents from the funding agency. The second section reiterates the scope of the proposal. Finally, there is a section of simple instructions for how to edit the whitepaper via GitHub's web interface with a mention that files in the repository can be edited locally on their machine.&lt;/p&gt;
&lt;h2&gt;Additional instructions&lt;/h2&gt;
&lt;p&gt;I've added a file of additional instructions regarding git, GitHub, markdown, and a few other odds-and-ends. I go into more detail about how to clone repos locally. This file is 633 words long. I'm not explicitly linking to it from the &lt;code&gt;README.md&lt;/code&gt;, but perhaps I will if there are too many questions.&lt;/p&gt;
&lt;h1&gt;Concerns&lt;/h1&gt;
&lt;p&gt;One of my main concerns is that the jump from editing a document locally on their computer in MS Word to editing a document on GitHub in markdown will be too large. Another concern is that I am not starting with a comprehensive tutorial of what git is and how the git workflow of forking, pull requests, branching, and merging works -- I'm simply showing them GitHub's web interface of a git repo and asking them to edit a document via that interface. Finally, I'm concerned that my collaborators will be turned off by the fact that markdown doesn't automatically do pagination like a word processor (the funding agency has a strict page limit on the whitepaper).&lt;/p&gt;
&lt;p&gt;Another big concern I have is how to transition my collaborators from the idea that they are editing a document on the web to the idea that they can edit documents locally on their machine, commit changes to the local repo, then push those changes to the remote.&lt;/p&gt;</summary></entry><entry><title>Writeup of my work on the Army Research Lab website</title><link href="http://jrsmith3.github.io/writeup-of-my-work-on-the-army-research-lab-website.html" rel="alternate"></link><updated>2014-04-07T18:21:00-04:00</updated><author><name>Joshua Ryan Smith</name></author><id>tag:jrsmith3.github.io,2014-04-07:writeup-of-my-work-on-the-army-research-lab-website.html</id><summary type="html">&lt;p&gt;This morning, a &lt;a href="http://www.arl.army.mil/www/default.cfm?article=2462"&gt;writeup&lt;/a&gt; of my research was featured on the Army Research Laboratory's website. I took a screenshot for posterity.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ARL website" src="images/screenshot-arl_website.png" title="ARL website" /&gt;&lt;/p&gt;</summary></entry><entry><title>Sample logs - the secret to managing multi-person projects</title><link href="http://jrsmith3.github.io/sample-logs-the-secret-to-managing-multi-person-projects.html" rel="alternate"></link><updated>2014-04-02T22:55:00-04:00</updated><author><name>Joshua Ryan Smith</name></author><id>tag:jrsmith3.github.io,2014-04-02:sample-logs-the-secret-to-managing-multi-person-projects.html</id><summary type="html">&lt;!-- Having embedded CSS is a hack, but I want the images to be side-by-side. 
I stole this CSS from: https://ghost.org/forum/using-ghost/1931-markdown-inline-images/
--&gt;

&lt;style type="text/css"&gt;
#myImages {
    width: auto; //need to keep div to the parent width so the text doesn't slide up
    margin-left: auto;
    margin-right: auto;
}
#myImages img {
    display: inline;
}
&lt;/style&gt;

&lt;h1&gt;Summary&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;a href="https://github.com/jrsmith3/sample_log"&gt;sample log&lt;/a&gt; is a record of all the events a sample experiences.&lt;/li&gt;
&lt;li&gt;Sample logs are necessary, especially if sample processing/analysis steps are preformed by different people.&lt;/li&gt;
&lt;li&gt;The fundamental unit of a sample log is an entry.&lt;/li&gt;
&lt;li&gt;Entries should be recorded at the time of event, not before or after.&lt;/li&gt;
&lt;li&gt;Each entry should record four pieces of information: &lt;ul&gt;
&lt;li&gt;A date/time stamp in &lt;a href="https://en.wikipedia.org/wiki/ISO_8601"&gt;YYYY-MM-DD HH:MM format&lt;/a&gt; where HH:MM is in 24h format.&lt;/li&gt;
&lt;li&gt;The event name.&lt;/li&gt;
&lt;li&gt;A brief description.&lt;/li&gt;
&lt;li&gt;Cross-references -- particularly lab notebooks and computer data files.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Sample logs should be stored alphabetically according to sample name in &lt;a href="http://www.amazon.com/exec/obidos/ASIN/B0006HVEI4"&gt;three-ring 1" binders&lt;/a&gt; in a central location.&lt;/li&gt;
&lt;li&gt;When moving between people and experiments, sample logs should be placed in &lt;a href="http://www.amazon.com/exec/obidos/ASIN/B00006IC89"&gt;plastic page protectors&lt;/a&gt; along with the sample in its case.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;A sample log is a record of all the events that a sample experiences. Sample logs are just as necessary as lab notebooks because they capture a set of information that simply isn't captured in a lab notebook. The necessity of such a record is particularly clear in projects where samples undergo process and analysis steps by many different people. Samples tend to move from place to place and from person to person; they have complex and eventful lifecycles.&lt;/p&gt;
&lt;div id = "myImages"&gt;
&lt;a href="images/samplelog_jrs0019_p1.png"&gt; &lt;img src="images/samplelog_jrs0019_p1_small.png" /&gt; &lt;/a&gt; &lt;a href="images/samplelog_jrs0019_p2.png"&gt; &lt;img src="images/samplelog_jrs0019_p2_small.png" /&gt; &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;You may think, "What purpose does a sample log serve? Isn't this information contained in lab notebooks?" In contrast to a lab notbook, a sample log won't contain a long narrative description of an experiment; it only contains a list of brief records of every event the sample experiences. Each entry contains the bare minimum amount of information with generous cross-referencing to the relevant lab notebooks and computer data files. In this way a reader of the sample log can comprehend the entire lifecycle of a sample, and the reader can follow the cross-references to find more details about particular events. There is not another source of information that provides these features. &lt;/p&gt;
&lt;p&gt;Sample logs and lab notebooks are good compliments to one another since they contain different types of information and serve different purposes -- the information in one is enhanced by the information in the other. In principle, a sample log could be constructed from the entries in a lab notebook, but in practice this task would be very time consuming -- especially since the records are likely split over multiple lab notebooks belonging to multiple people.&lt;/p&gt;
&lt;p&gt;Sample logs are composed of two components: metadata and the list of entries.&lt;/p&gt;
&lt;h1&gt;Sample log metadata&lt;/h1&gt;
&lt;p&gt;The metadata section contains information about the sample. Obviously, the sample log should include the sample's name. The sample's name should be unique (a method for choosing unique sample names will appear in a later post). Using unique names for samples gives you the added bonus of getting a unique name for your sample log.&lt;/p&gt;
&lt;p&gt;Beyond sample name, required metadata depends on the needs of individual labs. I've found it useful to record the size of the sample, the substrate, the manufacturer/supplier, and the manufacturer's metadata (lot number, etc.). Doping, structure, etc. is appropriate to record here.&lt;/p&gt;
&lt;p&gt;&lt;a href="images/samplelog_jrs0070_p1.png"&gt;&lt;img alt="Sample Log JRS0070, p1" src="images/samplelog_jrs0070_p1_small.png" title="Sample Log JRS0070, p1" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;Sample log entries&lt;/h1&gt;
&lt;p&gt;Entries are the fundamental unit of the sample log. Every time the sample experiences an event, an entry should be recorded. Each entry should have four components: date/time stamp, event name, brief description, and cross-reference. Entries should be recorded in pen. Each entry should be recorded on a new line.&lt;/p&gt;
&lt;div id = "myImages"&gt;
&lt;a href="images/samplelog_jrs0019_p1.png"&gt; &lt;img src="images/samplelog_jrs0019_p1_small.png" /&gt; &lt;/a&gt; &lt;a href="images/samplelog_jrs0019_p2.png"&gt; &lt;img src="images/samplelog_jrs0019_p2_small.png" /&gt; &lt;/a&gt;
&lt;/div&gt;

&lt;h2&gt;Date/time stamp&lt;/h2&gt;
&lt;p&gt;Each entry should have a date and time in &lt;a href="http://en.wikipedia.org/wiki/ISO_8601"&gt;YYYY-MM-DD HH:MM format&lt;/a&gt;. The time should be in 24-hour format which eliminates ambiguity. It is equally plausible that "8:45" refers to something that happened in the morning or the evening. On the other hand, "20:45" can only mean the evening.&lt;/p&gt;
&lt;h2&gt;Event name&lt;/h2&gt;
&lt;p&gt;The entry should name the event. Obviously, events that change the nature of the sample should be recorded: material deposition, material removal, annealing, and things of that sort. Additionally, experiments that characterize the sample should also be recorded: e.g. &lt;a href="http://en.wikipedia.org/wiki/X-ray_photoelectron_spectroscopy"&gt;XPS&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/atomic_force_microscope"&gt;AFM&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/x-ray_diffraction"&gt;XRD&lt;/a&gt;, I-V characterization of devices, etc. Third, it is generally useful to record the location of the sample: mounting to a sample holder, loading and unloading into an instrument, etc.&lt;/p&gt;
&lt;h2&gt;Event description&lt;/h2&gt;
&lt;p&gt;Every entry should also include any necessary, but brief, description. The description should not go into great detail about the experiment (detail should be recorded in the lab notebook), but it is sometimes useful to annotate the difference between events. For example, if the event is that the sample was loaded, the description would be the instrument. If the event is AFM is performed on the sample, the description might be the scan size (e.g. 1μm × 1μm). There isn't a hard and fast rule for what info should be recorded as the description, but its more based on the experience of the person writing things down.&lt;/p&gt;
&lt;h2&gt;Cross-reference&lt;/h2&gt;
&lt;p&gt;Finally, the records should have one or more cross-references, if applicable. Cross-references usually point to a page in a lab notebook or a filename. Since your lab notebook has a &lt;a href="https://jrsmith3.github.io/http://localhost:8000/effective-lab-notebooks.html"&gt;unique name&lt;/a&gt;, the cross-reference might look something like &lt;code&gt;JRS Lab Notebook 2014-02-27 p14&lt;/code&gt;. If the event you are recording results in a computer data file, the cross-reference to the &lt;a href="https://jrsmith3.github.io/naming-files-uniquely-to-reduce-confusion.html"&gt;uniquely named&lt;/a&gt; computer file might look like &lt;code&gt;20140217-2355_stm_0001_jrs.dat&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;Many times, an entry will have multiple cross-references. Put each cross-reference on a new line.&lt;/p&gt;
&lt;p&gt;&lt;a href="images/samplelog_jrs0075_p3_2011-02-05_18-55.png"&gt;&lt;img alt="Sample Log JRS0075, p3" src="images/samplelog_jrs0075_p3_2011-02-05_18-55_small.png" title="Sample Log JRS0075, p3" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;There are some events that probably don't require a reference. For example, loading a sample into an instrument won't likely have a reference unless there was some unusual circumstance associated with it, in which case the details should be recorded in a lab notebook and the reference noted on the sample log. &lt;/p&gt;
&lt;h1&gt;When should a new sample log be created vs. a new entry in an existing log?&lt;/h1&gt;
&lt;p&gt;A sample log should be started every time a sample is created. In my experience, it is best to consider each new individual piece of material as a unique sample. From this definition, there are only two events that would result in creating a new sample log:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Taking a new wafer out of the package from the manufacterer.&lt;/li&gt;
&lt;li&gt;Dicing/cleaving an existing wafer.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All other semiconductor processing and analysis to an existing sample would simply result in entries added to that sample's log. Examples of typical semiconductor processing are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Metal deposition via evaporation or sputtering.&lt;/li&gt;
&lt;li&gt;Wet etch.&lt;/li&gt;
&lt;li&gt;Plasma/RIE/dry etch.&lt;/li&gt;
&lt;li&gt;PECVD of dielectric.&lt;/li&gt;
&lt;li&gt;Lithographic patterning.&lt;/li&gt;
&lt;li&gt;Annealing.&lt;/li&gt;
&lt;li&gt;Etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note also that a single sample can contain many devices. You can imagine a photolithography mask with tens of Schottky diodes patterned on a single 10mm x 10mm die. The die would have its own sample log; C-V measurements done on an individual diode would generate an entry in that sample's log.&lt;/p&gt;
&lt;h1&gt;Does this advice apply to your lab?&lt;/h1&gt;
&lt;p&gt;What follows is a list of tips based on my experience working on projects at the intersection of device physics, surface science, materials science, and electrical engineering. I usually work with the typical materials science samples: mainly semiconductor wafers (Si, SiC, GaN) or insulating wafers (sapphire). I usually deal with some surface science analysis like XPS, AES, LEED, STM, or AFM. I also deal with processing steps like photolithography and metallization and analysis of fabricated devices like IV and CV measurements or microanalysis via SEM or EBIC. Samples usually start as 2" or 4" wafers and then are diced into smaller pieces during processing. If your work isn't based on wafers like mine, this approach may not apply. Also, my experience is in research science and not industrial process engineering or fab. I know the advice I give in this post applies to operations that deal with tens to a few hundred samples per year with a group encompassing four to around twenty people.&lt;/p&gt;
&lt;h1&gt;Recommendations&lt;/h1&gt;
&lt;p&gt;Creating and maintaining sample logs is a continual occurance and so I've created a &lt;a href="https://github.com/jrsmith3/sample_log"&gt;worksheet&lt;/a&gt;. For what its worth, I used an open-source program named &lt;a href="http://scribus.net"&gt;scribus&lt;/a&gt; to generate this worksheet and I've licensed it &lt;a href="https://creativecommons.org/licenses/by/4.0/"&gt;CC-BY 4.0&lt;/a&gt; to make it easy for others to modify it for their own needs.&lt;/p&gt;
&lt;p&gt;I recommend printing these worksheets instead of attempting to keep electronic sample logs. The advantages of electronic files (copying, publishing) aren't terribly beneficial for sample logs. On the other hand, electronic sample logs introduce issues of synchronization, backups, and findability.&lt;/p&gt;
&lt;p&gt;The sample log worksheet PDF is two pages. Once the two pages have been filled, the second page of the PDF can be printed and appended to the log. When a new page is appended, write the sample name at the top and the new page number at the bottom right in the spaces provided. If every new sample log page is marked with the sample name and page number, then that page implicitly gets a unique identifier (e.g. page n of the sample log of sample x). Thus, if someone finds the page lying on the ground, it is easy to return it to its proper place.&lt;/p&gt;
&lt;p&gt;I recommend punching holes in the sample logs with a three-hole punch (or printing them on pre-punched paper) and storing them in &lt;a href="http://www.amazon.com/exec/obidos/ASIN/B0006HVEI4"&gt;one-inch binders&lt;/a&gt;. I've found that in larger binders, pages flop around and eventually rip out. Don't pack the binder full, just start a new binder once the current binder starts to get full. I recommend labeling the binder(s) with "Sample Log" on the spine. I recommend against indexing the sample logs because I recommend adding individual sample logs alphabetically according to sample name (in other words, don't mark the binders with anything beyond "Sample Logs"). I'll go into more detail later with a recommendation on how to uniquely name samples so that their index grows chronologically. In that way, inserting new sample logs into the middle of a sample log is a rare occurance. Thus, once a binder gets filled, its unlikely that additional sample logs will need to be added which prevents shuffling sample logs through binders to make room.&lt;/p&gt;
&lt;p&gt;&lt;a href="images/samplelog_binders.jpg"&gt;&lt;img alt="Sample Log binders" src="images/samplelog_binders_small.jpg" title="Sample Log binders" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Binders containing sample logs should be kept in a central location, preferrably in the same location as lab notebooks and samples. Despite the binder suggestion, sample logs should travel with their sample as the sample moves from place to place. I've found that &lt;a href="http://www.amazon.com/exec/obidos/ASIN/B00006IC89"&gt;plastic page protectors&lt;/a&gt; are good for this purpose. If your sample is up to a 4" wafer, the wafer carrier can be slipped inside the plastic sleeve with the sample log and the entire packet can be passed between researchers. If any of the sample processing or analysis occurs in the cleanroom, sample logs should be printed on cleanroom paper.&lt;/p&gt;
&lt;p&gt;&lt;a href="images/samplelog_sample_jrs0033_sleeve.jpg"&gt;&lt;img alt="Sample log in plastic sleeve with wafer carrier." src="images/samplelog_sample_jrs0033_sleeve_small.jpg" title="Sample log in plastic sleeve with wafer carrier." /&gt;&lt;/a&gt;&lt;/p&gt;</summary></entry><entry><title>Naming data files</title><link href="http://jrsmith3.github.io/naming-data-files.html" rel="alternate"></link><updated>2014-02-28T23:21:00-05:00</updated><author><name>Joshua Ryan Smith</name></author><id>tag:jrsmith3.github.io,2014-02-28:naming-data-files.html</id><summary type="html">&lt;h1&gt;Summary&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Every filename should be unique.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Filenames should conform to the following format:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;YYYYMMDD-HHMM_experiment_sample_experimenter.extension&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If instruments have a short filename limit, use the following filesystem structure to parallel the long filename format above:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;experimenter/YYYYMMDD/experiment/sample/HHMM.extension&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;It seems like most groups have an ad-hoc and byzantine approach to managing computer data files that are generated by instruments in the course of research. Different researchers often have conflicting categorizational schemes using many levels of nested folders. These schemes likely aren't even self-consistent. Various versions of data are scattered across many different computers and have inconsistent names, all of which are at various stages of analysis or processing. Some are in the original format, some have been combined with other data files in MS Excel sheets, and the original pristine copies of some have been overwritten during processing.&lt;/p&gt;
&lt;p&gt;Herein I describe a scheme to eliminate those problems I just described that are caused by non-uniform or conflicting naming schemes for computer data files. This scheme will work for a small group (10 to 20 people, perhaps more). This scheme assumes the files aren't too big, tens to perhaps a few hundred &lt;a href="https://en.wikipedia.org/wiki/MiB"&gt;MiB&lt;/a&gt; on the high end, and that up to tens of data files are produced per day. This scheme is based on the use of unique identifiers (UIDs) and combinations of disjoint sets of metadata.&lt;/p&gt;
&lt;h1&gt;File naming&lt;/h1&gt;
&lt;p&gt;The nut; files should be named using the following format:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;YYYYMMDD-HHMM_experiment_sample_experimenter.extension&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Filenames are thus constructed from several pieces of disjoint kinds of metadata, separated by the underscore (_) character. Each component is described below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;YYYY: four-digit year (e.g. 2014, not 14)&lt;/li&gt;
&lt;li&gt;MM: two-digit month (e.g. 02, not 2)&lt;/li&gt;
&lt;li&gt;DD: two-digit day (e.g. 05, not 5)&lt;/li&gt;
&lt;li&gt;HH: two-digit hour in 24 hour format (e.g. 14, not 2pm. 09, not 9.)&lt;/li&gt;
&lt;li&gt;MM: two-digit minute&lt;/li&gt;
&lt;li&gt;experiment: name of technique (e.g. xps, afm, iv, etc.)&lt;/li&gt;
&lt;li&gt;sample: unique identifier of the sample&lt;/li&gt;
&lt;li&gt;experimenter: initials of the person who took the data (e.g. jrs).&lt;/li&gt;
&lt;li&gt;extension: the file extension (e.g. .tif, .dat).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The first few things you might notice about this scheme is that this scheme does not use an index; in other words, there's no xps0001.dat, xps0002.dat, etc. Also, the date goes year-month-day instead of month-day-year like many Americans are used to. Finally, this scheme seems like it will produce long filenames.&lt;/p&gt;
&lt;h2&gt;Time as an index (and other benefits)&lt;/h2&gt;
&lt;p&gt;The structure of the date/timestamp is a key part of this naming scheme, so I'm going to spend some time explaining the reasoning of using it. By specifying time to the resolution of minutes, one gets implicit indexing, even though the indices won't likely be sequential. I've found that sequential indexing with data filenames simply isn't that useful so long as every data file has a unique name. Moreover, manually indexing filenames is distracting for the experimenter; a small part of the experimenter's mind is occupied with the running index instead of focused on the experiment. Unless a computer is keeping track of the index, an experimenter may likely skip an index or repeat one which adds to the confusion.&lt;/p&gt;
&lt;p&gt;Typically experiments take longer than a minute to run, and so temporal resolution to the minute is usually sufficient to avoid name collisions. If higher temporal resolution is required, simply add seconds, etc. fields following the minutes.&lt;/p&gt;
&lt;p&gt;The order of the temporal denominations are important as well, and go from largest to smallest denomination of time. This ordering is based on the &lt;a href="http://en.wikipedia.org/wiki/ISO_8601"&gt;ISO 8601 standard&lt;/a&gt;. The use of 24-hour clock format reduces ambiguity and saves an extra character or two in filename length (am vs. pm). Formatting the date and time in this way is precise and unambiguous, which should be the aspiration of a scientist.&lt;/p&gt;
&lt;p&gt;Writing the date/timestamp in this way and putting it at the beginning of the filename yields the benefit that most computers will end up displaying the filenames sorted chronologically by default. Contrast this chronological sorting with the default sorting that would occur if the date was written MM-DD-YY or even MM-DD-YYYY.&lt;/p&gt;
&lt;h2&gt;The non-temporal metadata parts of the filename&lt;/h2&gt;
&lt;p&gt;The rest of the filename is composed of a few other bits of metadata. The &lt;code&gt;experiment&lt;/code&gt; field is necessary because the filename extension may not give enough information to determine it. For example, our scanning electron microscope generates &lt;a href="http://en.wikipedia.org/wiki/Tagged_Image_File_Format"&gt;tiff&lt;/a&gt; files, regardless of if it was imaging in &lt;a href="http://en.wikipedia.org/wiki/Scanning_electron_microscope#Detection_of_secondary_electrons"&gt;secondary electron mode&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/Scanning_electron_microscope#Detection_of_backscattered_electrons"&gt;backscatter mode&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/Electron_beam-induced_current"&gt;EBIC&lt;/a&gt;, or some other mode. I recommend trying to use no more than a three or four character string for the technique.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;sample&lt;/code&gt; field gives the name of the sample, which should be unique. I'll write more on choosing unique sample names later. The &lt;code&gt;experimenter&lt;/code&gt; field is useful for two reasons. First: attribution. Someone preparing a manuscript for publication can easily determine who contributed the data if this field is present in the filename. Second: responsibility. If this field is present, someone analyzing the data can track down the person who took the data and ask them questions.&lt;/p&gt;
&lt;h1&gt;Some advice and pitfalls to avoid&lt;/h1&gt;
&lt;p&gt;There were a few design criteria I was hoping to meet with this naming scheme. I wanted to have a rubric to generate a filename that was guaranteed to be unique. I also wanted to build in enough information so that a person could have a good idea of the contents and context of the file simply by looking at the name. Of course, you could always add even more metadata, but at some point the length of the filename will be unweildy and people won't follow the convention. To that end, the final design criterion was a convention that was long enough to be sufficiently descriptive, yet short enough that people would still use it. I would recommend that you not add additional metadata fields to this scheme.&lt;/p&gt;
&lt;p&gt;One last piece of advice, I recommend using all lowercase letters in your filenames.&lt;/p&gt;
&lt;p&gt;A big advantage of this scheme is that it allows you to leverage the search functionality of your operating system. For example, you could easily find all of the AFM images taken by me by searching for "afm" and "jrs". Additionally, it is simple to break apart the filename into useful metadata.&lt;/p&gt;
&lt;h1&gt;Dealing with old OSs that don't support long filenames&lt;/h1&gt;
&lt;p&gt;Many labs have old, but perfectly usable instruments that are controlled by old computers. Depending on the age, the operating system may not support long filenames. In this case, the file naming format I suggest won't work. In this case, I recommend using a nested directory structure to capture the full set of metadata -- just reverse the order of the metadata components.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;experimenter/YYYYMMDD/experiment/sample/HHMM.extension&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;It probably occurs to you that you wouldn't want a heterogeneous system containing short filename files within the nested directory structure along with the long filename files. In a future post I will discuss a computer data file workflow to deal with the issues that such a heterogeneous system would create.&lt;/p&gt;</summary></entry><entry><title>Effective lab notebooks</title><link href="http://jrsmith3.github.io/effective-lab-notebooks.html" rel="alternate"></link><updated>2014-02-27T22:50:00-05:00</updated><author><name>Joshua Ryan Smith</name></author><id>tag:jrsmith3.github.io,2014-02-27:effective-lab-notebooks.html</id><summary type="html">&lt;h1&gt;Summary&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Lab notebooks are collections of entries describing experiments performed in a lab.&lt;/li&gt;
&lt;li&gt;Use a bound, paper &lt;a href="http://www.amazon.com/exec/obidos/ASIN/B00007LV4B"&gt;lab notebook&lt;/a&gt;. It needs to have page numbers.&lt;/li&gt;
&lt;li&gt;Write in pen.&lt;/li&gt;
&lt;li&gt;Give each new lab notebook a uniquely identifying label: &lt;code&gt;&amp;lt;researcher's name&amp;gt; Lab Notebook &amp;lt;YYYY-MM-DD&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Put coordinates (email, phone, office) of the owner of the lab notebook on the cover of the notebook.&lt;/li&gt;
&lt;li&gt;Create a table of contents in the front four pages.&lt;/li&gt;
&lt;li&gt;Each new entry should have a date (YYYY-MM-DD), a title, and start on a new page.&lt;/li&gt;
&lt;li&gt;Entries should start with a plan of the experiments to be performed, contain notes and data as the experiment is performed, and at the end have a reflection of the experiment just performed.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Here are some notes on how to maintain a lab notebook based on my experience as a working scientist. I've found that this approach increases the value of my lab notebooks by giving a structure to the information I'm recording so I can spend more time thinking about the experiments I'm doing instead of what I should or shouldn't be writing down. Also, this system makes all the information recorded in your lab notebooks addressable and therefore easily cross-referenced. Finally, the information is recorded at several levels of detail, increasing the findability and contextualization of specific bits of information.&lt;/p&gt;
&lt;p&gt;Lab notebooks are where the realtime narrative of science is recorded. Lab notebooks are indeed narrative, but have a particular structure so that people can understand the important details and the sequence of scientific events at a later date (note "people" includes the person who wrote the notes). The lab notebook should be written in such a way that even years or decades later, a reader can reliably reconstruct the events. The structure serves to enhance the readability by making the information contained within more precise.&lt;/p&gt;
&lt;p&gt;Lab notebooks should include all of the organizational features that real technical books have evolved over the centuries: a name (a.k.a. title), a table of contents, and sectioning. The fundamental unit of a lab notebook is the entry.&lt;/p&gt;
&lt;h1&gt;Naming&lt;/h1&gt;
&lt;p&gt;Every lab notebook should be named with a unique identifier (UID). Even if you don't follow my recommended naming scheme, giving each lab notebook a UID is critically important. Your institution may have its own naming scheme. I recommend the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Researcher&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Lab&lt;/span&gt; &lt;span class="n"&gt;Notebook&lt;/span&gt; &lt;span class="n"&gt;YYYY&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;MM&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;DD&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Researcher's name is the full name of the researcher. I like to include the literal "Lab Notebook" so that readers can understand that a lab notebook is being referenced when the name is written down in a cross-reference. The final piece is the four-digit year, the two-digit month, and the two-digit day. Not only do I like this date format, it is an &lt;a href="http://en.wikipedia.org/wiki/ISO_8601"&gt;international standard&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This naming scheme has several advantages. It encodes the owner's name so that someone is responsible for the notebook's contents and so that credit can be attributed when papers are being written. The date string acts as an index for the notebook, albeit not sequential. Indexing with the date alleviates owners of lab notebooks from having to remember a running index of their lab notebooks every time they start a new one, thus helping to prevent name collisions. In addition, the date used as an index gives at-a-glance context for the contents of the notebook. Since it will likely take longer than a single day to fill a lab notebook, using the date as an index is unlikely to result in a naming collision.&lt;/p&gt;
&lt;p&gt;I recommend writing the name on the front of the notebook and on its spine. A &lt;a href="http://www.amazon.com/exec/obidos/ASIN/B00009RAX4"&gt;silver sharpie&lt;/a&gt; shows up well on the black spine of my &lt;a href="http://www.amazon.com/exec/obidos/ASIN/B00007LV4B"&gt;recommended notebook&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The coordinates of the notebook owner should also be written on the front of the notebook: email, phone, and office address.&lt;/p&gt;
&lt;p&gt;&lt;a href="images/cover.png"&gt;&lt;img alt="Front cover of lab notebook" src="images/cover_small.png" title="Front cover of lab notebook" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;Table of Contents&lt;/h1&gt;
&lt;p&gt;When starting a new lab notebook, I recommend reserving the first four pages for the table of contents if your notebook doesn't already have one. The actual table should have three columns: the left is the page number. Center: title of entry with sample numbers in parantheses. The right: date. The table of contents is an at-a-glance record of what is included in the notebook and makes the reader's job of comprehending the contents of the lab notebook much easier. You should add TOC information at the time you create a new entry.&lt;/p&gt;
&lt;p&gt;&lt;a href="images/toc.png"&gt;&lt;img alt="Table of contents" src="images/toc_small.png" title="Table of contents" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;Entry Metadata&lt;/h1&gt;
&lt;p&gt;Entries are the raison d'être of a lab notebook. The platonic ideal of a lab notebook entry is probably a single experiment. However, I've found that in reality my entries tend to capture single days in the lab. Before getting to what an entry should contain, every entry should include the date and title as metadata. Again, record the date in ISO 8601 format: YYYY-MM-DD. I record it on the top margin, left column. Every entry should have a title. I write it in the center of the top margin. Write a descriptive and concise title. Writing titles is very challenging, but gets easier with practice. Writing titles in this way has a strong focusing effect on your thinking, forcing you to cut inessential information.&lt;/p&gt;
&lt;p&gt;Every new entry should begin on a new page. There's no advantage to trying to conserve paper by doubling up entries on the same page. Obviously, some entries are going to span multiple pages and that's ok. If avoidable, entries &lt;em&gt;should not&lt;/em&gt; span separate lab notebooks. If they do, make sure to include the necessary back-references.&lt;/p&gt;
&lt;p&gt;Just to reiterate: add the entry to the table of contents at the time you create the entry. Your future self will thank you.&lt;/p&gt;
&lt;p&gt;&lt;a href="images/entry0.png"&gt;&lt;img alt="Entry" src="images/entry0_small.png" title="Entry" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;Contents of an Entry&lt;/h1&gt;
&lt;p&gt;So what should an entry contain? Generally speaking, I try to have three parts to my lab notebook entries: plan, record, and reflection. First, I write a description of the plan for the experiment. This section may include drawings of the experimental setup, block diagrams or schematics for instrumentation, etc. I may refer to papers in the literature. Don't short-change this subsection; writing your plan of work forces you to think through the problems you might encounter and gives you time to solve them before your experiment is underway.&lt;/p&gt;
&lt;p&gt;After the plan comes the main record of the experiment. The goal is to note every event that happens (valve #3 opened, power supply switched on, pump switched off) on a new line with the time of the record written in the left margin in 24h format (e.g. 15:27, not 3:27pm). I will record the names of computer files that are produced in the course of the experiment. I will also record instrumentation metadata like the setting on a potentiometer, or a temperature. Regarding instrumentation metadata, I make every effort to only record information once. In other words, I will record the settings on instrumentation if those settings are not being recorded in the computer data files that end up being saved in the course of the experiment. Every effort should be made to record &lt;em&gt;ALL&lt;/em&gt; the conditions of the instrumentation, especially settings that rarely or never change. I treat this step as a kind of ritual -- you might be surprised how often this ritual turns up instrumentation settings that should never change, but have. This ritual also gives you a very detailed understanding of your experimental setup and therefore reduces systemic mistakes. To ease the drudgery, I will create &lt;a href="https://github.com/jrsmith3/tfan_experiment_worksheets"&gt;worksheets&lt;/a&gt; for types of experiments I frequently repeat that I paste into my lab notebook (double-sided &lt;a href="http://www.amazon.com/exec/obidos/ASIN/B0035LXTYU"&gt;tape&lt;/a&gt;, actually). Any irregularities or unexpected occurences should be recorded as well (power failures, dropping samples, etc.).&lt;/p&gt;
&lt;p&gt;Once the experiment is over, I recommend writing a brief summary of what happened, how the results fit into your understanding of the bigger picture, and where you might go next. Again, don't short-change this subsection either. The present experiment's connection to all other aspects of your research will never be as clear in your mind as it is immediately after it is over.&lt;/p&gt;
&lt;p&gt;Despite the regimented structure I describe above, note well that above all else you are writing a narrative for an audience. Write what will be most helpful to your future readers (particularly your future self) and write it in a way that is readable (enjoyable, even). Writing good lab notebook entries is an art like all other writing exercises: you improve with practice. It is more important to write bad sentences than no sentences. Focus on recording your data and instrumentation settings accurately and eventually you will learn the appropriate level of narrative detail.&lt;/p&gt;
&lt;p&gt;&lt;a href="images/entry1.png"&gt;&lt;img alt="Entry" src="images/entry1_small.png" title="Entry" /&gt;&lt;/a&gt;
&lt;a href="images/entry2.png"&gt;&lt;img alt="Entry" src="images/entry2_small.png" title="Entry" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;Added Advantages&lt;/h1&gt;
&lt;p&gt;Structuring your lab notebook in the way I describe yields several benefits. First, the structure, particularly the fact that the notebook name is a UID, makes all the information in all of your lab notebooks easily addressible. You can refer to a precise event using the name of the notebook, page number, and timestamp of event. Second, having a structure reduces your cognitive load which allows you to focus maximum attention on your work. Third, the table of contents along with descriptive entry names, sample numbers, and dates gives a high-level overview of the contents of the lab notebook.&lt;/p&gt;
&lt;h1&gt;General Advice&lt;/h1&gt;
&lt;p&gt;In order to avoid entries that span notebooks, archive your notebook when an entry cuts into the last 15 pages.&lt;/p&gt;
&lt;p&gt;Paper notebooks are better than electronic notebooks in my experience. Electronic notebooks have some advantages (publishing, copying) but paper's advantages outweigh them. Paper is malleable in that you can draw whatever you like. It is immediate: you don't have to power it up, log in, etc. so you are more likely to use it. Paper doesn't have DRM or legal restrictions/licensing fees, etc.&lt;/p&gt;
&lt;p&gt;Pre-bound notebooks should be used instead of loose-leaf notebooks. Pre-bound notebooks show tampering. They are better for patent claims and tech transfer (in a way that no attorney has sufficiently explained to me).&lt;/p&gt;
&lt;p&gt;Like samples and sample logs, lab notebooks should be stored in a central location.&lt;/p&gt;
&lt;p&gt;Don't tear pages out of lab notebooks. All this advice also applies to &lt;a href="http://www.amazon.com/exec/obidos/ASIN/B0054RIENY"&gt;cleanroom notebooks&lt;/a&gt;&lt;/p&gt;</summary></entry><entry><title>Hello World</title><link href="http://jrsmith3.github.io/hello-world.html" rel="alternate"></link><updated>2013-09-10T17:37:00-04:00</updated><author><name>Joshua Ryan Smith</name></author><id>tag:jrsmith3.github.io,2013-09-10:hello-world.html</id><summary type="html">&lt;p&gt;My name is Joshua Ryan Smith and I am a physicist. This is my blog. For several years now I've been thinking that I need a place to put ideas, and I think pelican + github is a really elegant way to create a blog.&lt;/p&gt;
&lt;p&gt;Based on my experience as a working scientist, I've learned some practical lessons about the practice of science -- particularly computational and experimental surface science. I've also developed a perspective of what science is as well as how it relates to the wider society. I want to record these ideas and share them. I also want to have a mechanism of accountability in the sense that I'd like to rebalance on the side of getting ideas out sooner that may be less polished (or just plain wrong) rather than waiting for them to attain an impossible perfection.&lt;/p&gt;
&lt;p&gt;Regarding audience, I have a few people in mind to whom I'm writing this blog, both scientists and non. My goal is that colleagues in my field of research read this blog. Additionally, I want to write such that people from other fields find the material approachable and interesting.&lt;/p&gt;
&lt;p&gt;I'm aiming for about 1000 words per post and one post per week. I'm not going to have comments at first because I have no idea how to manage them. However, feel free to contact me via email: &lt;a href="mailto:joshua.r.smith@gmail.com"&gt;joshua.r.smith@gmail.com&lt;/a&gt;. I'm also on twitter: &lt;a href="https://twitter.com/joshua_r_smith/"&gt;@joshua_r_smith&lt;/a&gt;.&lt;/p&gt;</summary></entry></feed>